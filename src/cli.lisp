(in-package :fkpos-cli)

(eval-when (:execute :compile-toplevel :load-toplevel)
  (declaim (optimize (safety 3) (debug 3) (speed 0) (space 0) (compilation-speed 0))))

(defun ts () (fkpos:str (fkpos:timestamp)))
(defun ls () (fkpos:ls fkpos:*curr-db*))
(defun ll ()
  (loop for n being the hash-value of (fkpos:children fkpos:*curr-db*)
        collect (fkpos:info (fkpos:ref n))))
(defun new (ot &optional title)
  (if title (fkpos:new fkpos:*curr-db* ot title)
      (fkpos:new fkpos:*curr-db* ot)))
(defun fv (field value &rest rest)
  (prog1 (fkpos:fv fkpos:*curr-db* field value)
    (when rest (apply #'fv (first rest) (second rest) (cddr rest)))))
(defun rm (name) (fkpos:rm fkpos:*curr-db* name))
(defun co (&rest names)
  (if (not names) (fkpos:co fkpos:*curr-db*)
      (loop for name in names
            for obj = (if (eql name :root)
                          (fkpos:co fkpos:*curr-db*)
                          (fkpos:co fkpos:*curr-db* name))
            finally (return obj))))
(defun pp () (fkpos:pp fkpos:*curr-db*))
(defun ln (n) (fkpos:ln fkpos:*curr-db* n))
(defun info () (fkpos:info fkpos:*curr-db*))
(defun obj (&rest path) (fkpos:obj fkpos:*db* path))
(defun value (currency) (fkpos:value fkpos:*curr-db* currency))

;(co)
;(co :categories)
;(new :category :test1)
;(new :category :test2)
;(co :test2)
;(new :category :test3)
;(new :category :test4)
;(co :parent)
;(new :category :test5)
;(co)
;(co :components)
;(new :component :tc1)
;(co :tc1)
;(fv :descr "tc1 descr")
;(fv :price (cons 10.30 :NOK))
;(fv :sell? t)
;(ln (obj :categories :test1))
;(ln (obj :categories :test2))
;(co :parent)
;(new :component :tc2)
;(co :tc2)
;(fv :descr "tc2 descr")
;(fv :price (cons 20 :NOK))
;(new :usage :tc1usage)
;(co :tc1usage)
;(fv :amount 7)
;(ln (obj :components :tc1))
;(co :parent)
;(ln (obj :categories :test2))
;(co)
;(co :transactions)
;(new :transaction :trans-1)
;(co :trans-1)
;(ln (obj :components :tc1))
;(new :payment :pay-1)
;(co :pay-1)
;(fv :amount (cons 10 :NOK))
;(co)
